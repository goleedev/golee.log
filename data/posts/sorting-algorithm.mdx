---
title: "ğŸ‘€ Sorting Algorithm í•œë²ˆì— ì´í•´í•˜ê¸°"
thumbSrc: "/static/images/algo1.png"
date: "2021-06-11"
tags: ["CS"]
draft: false
summary: "ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì„ í•™ìŠµí•˜ë©´ì„œ ì •ë¦¬í•œ ìë£Œë¡œ, ê° ì •ë ¬ì˜ ì‹œê°„ ë³µì¡ë„ì™€ íŠ¹ì§•ì„ ì„¤ëª…í•˜ê³  ìˆìŠµë‹ˆë‹¤."
images:
  [
    "/static/images/algo1.png",
    "/static/images/bubble1.png",
    "/static/images/bubble2.png",
    "/static/images/selection1.png",
    "/static/images/selection2.png",
    "/static/images/insertion1.png",
    "/static/images/insertion2.png",
    "/static/images/quick1.png",
    "/static/images/merge1.png",
    "/static/images/heap1.png",
  ]
---

# ğŸ“Œ ëª©ì°¨

![Sorting Algorithm]/images/algo1.png)

- **ğŸ’ğŸ» ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì´ë€**

- **ğŸ§¼ ë²„ë¸” ì •ë ¬ (Bubble Sort)**

- **ğŸª™ ì‚½ì… ì •ë ¬(Insertion sort)**

- **ğŸ›’ ì„ íƒì •ë ¬ (Selection sort)**

- **âš¡ í€µ ì •ë ¬ (Quick sort)**

- **ğŸ¤² ë³‘í•© ì •ë ¬ (Merge Sort)**

- **âºï¸ í™ ì •ë ¬ (Heap Sort)**

- **âŒ› ì‹œê°„ ë³µì¡ë„ (Time Complexity)**

---

# ğŸ’ğŸ» ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì´ë€

ì»´í“¨í„° ê³¼í•™ê³¼ ìˆ˜í•™ì—ì„œ `ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ (sorting algorithm)`ì´ë€ **ì›ì†Œë“¤ì„ ë²ˆí˜¸ìˆœì´ë‚˜ ì‚¬ì „ ìˆœì„œì™€ ê°™ì´ ì¼ì •í•œ ìˆœì„œëŒ€ë¡œ ì—´ê±°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜**ì…ë‹ˆë‹¤.

ì´ëŠ” ì»´í“¨í„°ì—ì„œ ê°€ì¥ ë§ì´ ì´ìš©ë˜ëŠ” ì—°ì‚° ì¤‘ í•˜ë‚˜ì´ë©°, **ìë£Œê²€ìƒ‰ì˜ íš¨ìœ¨ì„±ì„ ì¸¡ì •í•˜ê³  ì‹¤ìš©ì„±ê³¼ ì´ë¡  ì„¤ëª… ë“±ì„ ìœ„í•´ì„œ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì´ í•„ìš”**í•©ë‹ˆë‹¤.

ì´ëŸ¬í•œ ì •ë ¬ì„ ìˆ˜í–‰í•˜ëŠ” ë‹¤ì–‘í•œ ì•Œê³ ë¦¬ì¦˜ë“¤ì´ ìˆìœ¼ë©°, **100ê°œ ì´ìƒì˜ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ë“¤ì´ ê°œë°œ**ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

í•´ë‹¹ ê¸€ì—ì„œëŠ” ëª‡ ê°€ì§€ **ëŒ€í‘œì ì¸ ì •ë ¬ ì•Œê³ ë¦¬**ì¦˜ë§Œ ë‹¤ë£° ì˜ˆì •ì…ë‹ˆë‹¤.

---

# ğŸ§¼ ë²„ë¸” ì •ë ¬ (Bubble Sort)

> 2ê°œì˜ ì¸ì ‘í•œ ë°ì´í„°ë¥¼ ë¹„êµí•´ì„œ ì•ì— ìˆëŠ” ë°ì´í„°ê°€ ë’¤ì— ìˆëŠ” ë°ì´í„°ë³´ë‹¤ í¬ë©´ ìë¦¬ë¥¼ ë°”ê¾¸ëŠ” ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.

## ê·¸ë¦¼ìœ¼ë¡œ ì´í•´í•˜ê¸°

![Bubble 1]/images/bubble1.png)

![Bubble 2]/images/bubble2.png)

## ì½”ë“œë¡œ ì´í•´í•˜ê¸°

```javascript
function bubbleSort(arr) {
	for (let i = 0; i < arr.length; i++) {
		for (let j = 0; j < arr.length - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				var temp = arr[j]

				arr[j] = arr[j + 1]
				arr[j + 1] = temp
			}
		}
	}

	console.log(arr)
}
```

---

# ğŸª™ ì‚½ì… ì •ë ¬(Insertion sort)

> ì‚½ì… ì •ë ¬ì€ ìì‹ ë³´ë‹¤ ì•ì˜ ì›ì†Œê°€ í°ì§€ ì‘ì€ì§€ ë¹„êµë¥¼ í•œí›„ ì•Œë§ì€ ìœ„ì¹˜ë¥¼ ì°¾ì•„ì„œ í•´ë‹¹ ì›ì†Œë¥¼ 'ì‚½ì…' í•˜ëŠ” ì •ë ¬ì…ë‹ˆë‹¤.
> ì‚½ì… ì •ë ¬ì€ ìì‹ ë³´ë‹¤ ì•ì— ìœ„ì¹˜í•œ ì›ì†Œì™€ ë¹„êµí•˜ë¯€ë¡œ, ì²«ë²ˆì§¸ indexëŠ” ì´ë¯¸ ì •ë ¬ë˜ì—ˆë‹¤ê³  ê°€ì •í•˜ê³  2ë²ˆì§¸ indexë¶€í„° ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤.
> ë”°ë¼ì„œ ì‚½ì… ì •ë ¬ì€ ë‘ ë²ˆì§¸ ì›ì†Œë¶€í„° ì‹œì‘í•´ì„œ ê·¸ ì•ì˜ ì›ì†Œë“¤ê³¼ ë¹„êµí•´ ì‚½ì…í•  ìœ„ì¹˜ë¥¼ ì§€ì •í•œ í›„, ì§€ì •í•œ ìë¦¬ì— ì›ì†Œë¥¼ ì‚½ì…í•´ ì •ë ¬í•©ë‹ˆë‹¤.

## ê·¸ë¦¼ìœ¼ë¡œ ì´í•´í•˜ê¸°

![Insertion 1]/images/insertion1.png)

![Insertion 2]/images/insertion2.png)

## ì½”ë“œë¡œ ì´í•´í•˜ê¸°

```javascript
function insertionSort(arr, n) {
	let i, key, j

	for (i = 1; i < n; i++) {
		key = arr[i]
		j = i - 1

		while (j >= 0 && arr[j] > key) {
			arr[j + 1] = arr[j]
			j = j - 1
		}
		arr[j + 1] = key
	}
}
```

---

# ğŸ›’ ì„ íƒì •ë ¬ (Selection sort)

> ì„ íƒì •ë ¬ì€ ì •ë ¬ë˜ì§€ ì•Šì€ ë°ì´í„°ì—ì„œ ê°€ì¥ ì‘ì€ ê°’ì„ ë½‘ì•„ ê°€ì¥ ì•ì˜ ë°ì´í„°ì™€ êµí™˜í•˜ëŠ” ì •ë ¬ ë°©ì‹ì…ë‹ˆë‹¤.

## ê·¸ë¦¼ìœ¼ë¡œ ì´í•´í•˜ê¸°

![Selection 1]/images/selection1.png)

![Selection 2]/images/selection2.png)

## ì½”ë“œë¡œ ì´í•´í•˜ê¸°

```javascript
function swap(arr, xp, yp) {
	var temp = arr[xp]
	arr[xp] = arr[yp]
	arr[yp] = temp
}

function selectionSort(arr, n) {
	var i, j, min_idx

	for (i = 0; i < n - 1; i++) {
		min_idx = i
		for (j = i + 1; j < n; j++) if (arr[j] < arr[min_idx]) min_idx = j

		swap(arr, min_idx, i)
	}
}
```

---

# âš¡ í€µ ì •ë ¬ (Quick sort)

> í€µ ì •ë ¬ì€ ê¸°ì¤€ì (pivot)ì„ ì •í•´ ê¸°ì¤€ì ë³´ë‹¤ ì‘ì€ ë°ì´í„°ëŠ” ì™¼ìª½, í° ë°ì´í„°ëŠ” ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.
> ê¸°ì¤€ì ì˜ ê° ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì—ëŠ” ì¬ê·€ ìš©ë²•ì„ ì‚¬ìš©í•˜ì—¬ ìƒê¸°ì˜ ì‘ì—…ì„ ë°˜ë³µí•©ë‹ˆë‹¤.

## ê·¸ë¦¼ìœ¼ë¡œ ì´í•´í•˜ê¸°

![Quick 1]/images/quick1.png)

## ì½”ë“œë¡œ ì´í•´í•˜ê¸°

```javascript
function quickSort(arr) {
	if (arr.length < 2) {
		return arr
	}

	let pivot = [arr[0]]
	let left = []
	let right = []

	for (let i = 1; i < arr.length; i++) {
		if (arr[i] < pivot) {
			left.push(arr[i])
		} else if (arr[i] > pivot) {
			right.push(arr[i])
		} else {
			pivot.push(arr[i])
		}
	}

	console.log(`left: ${left}, pivot: ${pivot}, right: ${right}`)
	return quickSort(left).concat(pivot, quickSort(right))
}
```

---

# ğŸ¤² ë³‘í•© ì •ë ¬ (Merge Sort)

> ë³‘í•© ì •ë ¬ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ ì ˆë°˜ìœ¼ë¡œ ë‹ˆëŠì•„ ë¹„ìŠ·í•œ í¬ê¸°ì˜ ë‘ ë¦¬ìŠ¤íŠ¸ë¡œ ë‚˜ëˆˆ í›„, ê° ë¦¬ìŠ¤íŠ¸ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ë³‘í•© ì •ë ¬ì„ ì´ìš©í•´ ì •ë ¬í•©ë‹ˆë‹¤.
> ê·¸ ë‹¤ìŒ, ë‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ë‹¤ì‹œ í•˜ë‚˜ì˜ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¡œ í•©ì³ì¤ë‹ˆë‹¤.

## ê·¸ë¦¼ìœ¼ë¡œ ì´í•´í•˜ê¸°

![Merge 1]/images/merge1.png)

## ì½”ë“œë¡œ ì´í•´í•˜ê¸°

```javascript
const merge = function (left, right) {
	const result = []
	while (left.length !== 0 && right.length !== 0) {
		left[0] <= right[0] ? result.push(left.shift()) : result.push(right.shift())
	}

	return [...result, ...left, ...right]
}

const mergeSort = function (array) {
	if (array.length === 1) return array

	const middleIndex = Math.floor(array.length / 2)
	const left = array.slice(0, middleIndex)
	const right = array.slice(middleIndex)

	return merge(mergeSort(left), mergeSort(right))
}
```

---

# âºï¸ í™ ì •ë ¬ (Heap Sort)

> í™ì€ í° í‚¤(ìš°ì„  ìˆœìœ„)ì— ìì£¼ ì•¡ì„¸ìŠ¤í•˜ê±°ë‚˜ í‚¤(ìš°ì„  ìˆœìœ„) ì¤‘ì‹¬ìœ¼ë¡œ ì •ë ¬ëœ ì‹œí€€ìŠ¤ë¥¼ í™œìš©í•´ì•¼ í•  ë•Œ ìœ ìš©í•œ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.
> í™ì€ í•œ ë…¸ë“œ(node)ê°€ ìµœëŒ€ ë‘ ê°œì˜ ìì‹ë…¸ë“œ(child node)ë¥¼ ê°€ì§€ë©´ì„œ,
> ë§ˆì§€ë§‰ ë ˆë²¨ì„ ì œì™¸í•œ ëª¨ë“  ë ˆë²¨ì—ì„œ ë…¸ë“œë“¤ì´ ê½‰ ì±„ì›Œì§„ ì™„ì „ì´ì§„íŠ¸ë¦¬(complete binary tree)ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í•©ë‹ˆë‹¤.

## ê·¸ë¦¼ìœ¼ë¡œ ì´í•´í•˜ê¸°

![Heap 1]/images/heap1.png)

## ì½”ë“œë¡œ ì´í•´í•˜ê¸°

```javascript
const buildMaxHeap = (arr) => {
	let i = Math.floor(arr.length / 2 - 1)

	while (i >= 0) {
		heapify(arr, i, arr.length)
		i -= 1
	}
}

const heapify = (heap, i, max) => {
	let index
	let leftChild
	let rightChild

	while (i < max) {
		index = i
		leftChild = 2 * i + 1
		rightChild = leftChild + 1

		if (leftChild < max && heap[leftChild] > heap[index]) {
			index = leftChild
		}

		if (rightChild < max && heap[rightChild] > heap[index]) {
			index = rightChild
		}

		if (index === i) {
			return
		}

		swap(heap, i, index)
		i = index
	}
}

const swap = (arr, firstItemIndex, lastItemIndex) => {
	const temp = arr[firstItemIndex]

	arr[firstItemIndex] = arr[lastItemIndex]
	arr[lastItemIndex] = temp
}

const heapSort = (arr) => {
	buildMaxHeap(arr)
	lastElement = arr.length - 1

	while (lastElement > 0) {
		swap(arr, 0, lastElement)
		heapify(arr, 0, lastElement)
		lastElement -= 1
	}

	return arr
}
```

---

# âŒ› ì‹œê°„ ë³µì¡ë„ (Time Complexity)

| **Algorithm**      | **Time Complexity** |             |             |
| ------------------ | ------------------- | ----------- | ----------- |
|                    | **Best**            | **Average** | **Worst**   |
| **Bubble Sort**    | Î©(n)                | Î¸(n^2)      | O(n^2)      |
| **Insertion Sort** | Î©(n)                | Î¸(n^2)      | O(n^2)      |
| **Selection Sort** | Î©(n^2)              | Î¸(n^2)      | O(n^2)      |
| **Quick Sort**     | Î©(n log(n))         | Î¸(n log(n)) | O(n^2)      |
| **Merge Sort**     | Î©(n log(n))         | Î¸(n log(n)) | O(n log(n)) |
| **Heap Sort**      | Î©(n log(n))         | Î¸(n log(n)) | O(n log(n)) |

---

### ğŸ”— References

[GeeksForGeeks](https://www.geeksforgeeks.org/bubble-sort-algorithms-by-using-javascript/)

[Sorting Algorithms](https://www.interviewbit.com/tutorial/sorting-algorithms/)
